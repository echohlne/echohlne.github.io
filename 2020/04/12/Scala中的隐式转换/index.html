<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="echohlne">
    
    <title>
        
            Scala中的隐式转换 |
        
        echohlne&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"echohlne.github.io","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"1200px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                echohlne&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Scala中的隐式转换</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">echohlne</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-04-12 23:15:33
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Scala/">Scala</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/summary/">summary</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>在很多Scala的高级应用中，隐式转换都是非常常见的操作。它本质上以OCP开闭原则为核心思想，其用法也非常多样，我们可以利用它来实现装饰者模式，或者实现映射功能，或者选择将繁琐、晦涩、对于代码调用者而言无需深入理解的代码部分隐藏掉。</p>
<p>此外，由于Scala支持使用符号作为函数标识符，结合隐式转换可以实现相当多的内部语法特性(也可以称它是内部DSL)。 尤其对于集合以及元素操作而言， Scala使用大量精简的符号替代掉了 <code>concat</code>, <code>add</code>, <code>remove</code> 等相对冗长的英文函数名， 而我们仅需要像写简单算算式一样就能实现集合操作。 比如 对于 Scala 的 Map集合， 我们可以使用 <code>key</code> -&gt; <code>value</code> 的写法来生动地表示存储了一个键值对。 然后 <code>-&gt;</code>并不是Scala本身支持的语法或者是符号，而是利用隐式转换包装出来的一个”语法糖”。 为什么要这么做? 在大部分情况下， 函数标识符使用简单符号作为助记符要比一大串的英文单词直观的多， 这对于追求简洁，精巧的Scala而言最合适不过了。 再比如我们更倾向于使用 <code>1+1</code>来表达”1 加 1”， 而不是 <code>1 add 1</code> 或者 <code>1.add(1)</code>。</p>
<p>本文中，会同时介绍隐式转换和自定义操作符的相关概念，并通过一个自实现”单位转换”的实例来感受隐式转换的妙用。 隐式转换为Scala提供灵活性的同时，还有不可言状的”神秘感”, 以至于在你很难直接理解一些Scala库的”魔术”代码，原因就是库内部存在着大量的隐式转换。</p>
<h1 id="隐式转换函数"><a href="#隐式转换函数" class="headerlink" title="隐式转换函数"></a>隐式转换函数</h1><p>首先从一个最基本的例子说起。 Scala中的所有数据类型都提供了 <code>toXXX</code> 方法对于数据进行显示转换:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> converToInt:<span class="type">Int</span> = <span class="number">3.6</span>.toInt</span><br><span class="line">println(<span class="string">s&quot;convertToInt=<span class="subst">$&#123;converToInt&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>但是， 当一段代码的很多处都存在对这种数据转换的需求，我们就不得不在每一处都附带上 <code>toXXX</code>。 这也是引入隐式转换机制的一大原因：编译器在编译期间能够自动地识别出需要隐式转换的代码，而程序开发者需要提供对应的转换方式：隐式转换函数，隐式类。</p>
<h2 id="隐式转换函数实现转换数据类型"><a href="#隐式转换函数实现转换数据类型" class="headerlink" title="隐式转换函数实现转换数据类型"></a>隐式转换函数实现转换数据类型</h2><p>继续上个例子来讨论， 我们希望 <code>Double</code> 到 <code>Int</code> 的数据转换能够让编译器自行处理(即隐式转换)， 而不需要每一次都手动地通过 <code>.toInt</code> 来实现。 这里要引入一个全新的关键字 <code>implicit</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertDoubleToInt</span></span>(doubleNumber: <span class="type">Double</span>):<span class="type">Int</span> = doubleNumber.toInt</span><br></pre></td></tr></table></figure>

<p>其中，<strong>函数名可以自行定义， 能够体现功能即可</strong>， 因为编译器仅依赖函数签名来搜索合适的隐式函数， 签名指函数的参数列表和返回值。 隐式转换函数是典型的 <code>Function&lt;T, R&gt;</code> 类型， 传入需要被处理(或称被转换)的 <code>T</code> 类型参数， 并生产(或称提供)出被转换后的<code>R</code>类型的值。</p>
<p>需要注意的是: <strong>隐式转换函数在声明它的当前作用域以及子域内自动生效</strong>。因此在声明一个隐式转换函数时， 尤其要注意要向上的作用域中是否定义了签名重复的隐式转换函数。</p>
<p>如果在主函数内声明该隐式转换函数，则主函数内所有由 <code>Double </code>到 <code>Int</code> 的赋值都将由编译器通过 <code>convertDoubleToInt</code> 函数来自动替换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> doubleNumber:<span class="type">Int</span> = <span class="number">3.5</span></span><br><span class="line">    println(<span class="string">s&quot;doubleNumber=<span class="subst">$doubleNumber</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertDoubleToInt</span></span>(doubleNumber: <span class="type">Double</span>):<span class="type">Int</span> = doubleNumber.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，在开发中， 我们应尽可能在<strong>最小的适用范围内</strong>定义隐式转换函数， 避免隐式转换函数对其他作用域也造成影响。</p>
<h2 id="利用隐式转换实现Map映射"><a href="#利用隐式转换实现Map映射" class="headerlink" title="利用隐式转换实现Map映射"></a>利用隐式转换实现Map映射</h2><p>隐式转换是典型的<code>Function&lt;T, R&gt;</code>型函数，我们可以稍加利用， 并实现 Map映射的功能。 举个例子:举个例子：有具备 <code>age</code> 和 <code>name</code> 属性的学生类 <code>Student</code>。现在希望当用字符串引用<code>studentInfo</code>去指向 <code>Student</code> 实例的时候，编译器能优雅地做如下处理：将这个学生的信息拼接成字符串并返回给<code>studentInfo</code>引用，而不是报错。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">printStudent</span></span>(student: <span class="type">Student</span>) = student.name + <span class="string">&quot;-&quot;</span> + student.age</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> studentInfo: <span class="type">String</span> = <span class="type">Student</span>(<span class="string">&quot;zhou joy&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    println(<span class="string">s&quot;StudentInfo=<span class="subst">$studentInfo</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="隐式转换函数的-OCP-哲学"><a href="#隐式转换函数的-OCP-哲学" class="headerlink" title="隐式转换函数的 OCP 哲学"></a>隐式转换函数的 OCP 哲学</h2><blockquote>
<p>OCP 原则，即开闭原则，对修改关闭，对拓展开放。</p>
</blockquote>
<p>用一个例子来说明：假设现在有 <code>JDBC</code> 的原生组件，我们希望在不修改原本的核心代码的基础上，对 <code>JDBC</code> 进行一些额外功能拓展。在 Scala 中，这样的需求可以使用隐式函数来实现。给定不可修改的模拟 <code>JDBC</code> 类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> url:<span class="type">String</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将新功能 “外挂” 到一个功能更强大的类 <code>Mybatis</code> 上。它不仅具备 <code>JDBC</code> 的原有内容，还新增了自己的属性和方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBatis</span>(<span class="params">val url : <span class="type">String</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> maxConnection : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Pool</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">      print(<span class="string">s&quot;获取连接池信息:<span class="subst">$url</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中声明一个将 <code>JDBC</code> 升级为 <code>Mybatis</code> 的隐式转换函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">JDBC_</span></span>(jDBC: <span class="type">JDBC</span>) :<span class="type">MyBatis</span> =<span class="keyword">new</span> <span class="type">MyBatis</span>(jDBC.url)</span><br></pre></td></tr></table></figure>

<p>随后，在主函数域内定义的所有 <code>JDBC</code> 实例便可以使用 <code>Mybatis</code> 带来的新功能和新属性了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdbc.<span class="type">Pool</span>()</span><br><span class="line">println(jdbc.maxConnection)</span><br></pre></td></tr></table></figure>

<p>从视觉效果来看，<code>JDBC</code> 好像是直接获得了 <code>Mybatis</code> 的功能，实则是编译器通过隐式转换将 <code>JDBC</code> “调包” 成了 <code>Mybatis</code> 组件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JDBC_</span>(jdbc).<span class="type">Pool</span>()</span><br></pre></td></tr></table></figure>

<p>如此一来，便很容易理解了：又是 Scala 惯用的 “移花接木” （换个文雅的称呼，即 “<strong>装饰者模式</strong>“ ）的伎俩。</p>
<p>回忆之前所学的动态混入特质，它其实也可以实现类似的目的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">enhancedJDBC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>:<span class="type">JDBC</span>=&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Pool</span></span>() : <span class="type">Unit</span> =&#123;</span><br><span class="line">    print(<span class="string">s&quot;获取连接池信息:<span class="subst">$url</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> maxConnection : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于需要拓展功能的 <code>JDBC</code> 实例，只需要动态混入该特质即可。我个人的理解是：特质更偏向于动态插拔灵活组装，而隐式函数转换则偏向于对外隐匿繁琐的转换细节。不过注意，过度使用隐式转换会大大降低代码的可读性。</p>
<p>注：针对这个例子，我们还可以使用隐式类来实现。</p>
<h2 id="隐式转换函数总结要点"><a href="#隐式转换函数总结要点" class="headerlink" title="隐式转换函数总结要点"></a>隐式转换函数总结要点</h2><ul>
<li><p>隐式函数的名字不会到影响编译器的定位，它只依赖函数签名来匹配合适的隐式转换函数。</p>
</li>
<li><p>隐式函数之间的<strong>签名要区别开</strong>，不要产生二义性。</p>
</li>
<li><p>利用隐式函数可以实现<strong>映射</strong>或者<strong>装饰者</strong>功能。</p>
</li>
<li><p>隐式函数不能递归调用自身。</p>
</li>
</ul>
<h1 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h1><p>Scala 2.10 版本后还可以用 <code>implicit</code> 关键字声明类，则这个类称之为隐式类。隐式类从用法，及其设计思想来看，和隐式函数没有太大区别，只不过它是将针对某一个数据类型的一系列增强方法和属性封装到了另一个结构体当中（OOP 思想）。</p>
<p>隐式类的特点:</p>
<ul>
<li>构造方法的参数列表内有且只有一个参数，该参数的类型决定了此隐式类要增强的目标类型</li>
<li>隐式类不能是顶级的类(top-level objects), 它总是作为内部类或局部成员出现</li>
<li>隐式类不可以做模板类(模板类和模式匹配有关)</li>
<li>作用域内不能有同名方法，同名内部类</li>
<li>它能实现的功能用隐式转换函数也可以去实现</li>
</ul>
<h2 id="从底层编译的角度观察隐式类"><a href="#从底层编译的角度观察隐式类" class="headerlink" title="从底层编译的角度观察隐式类"></a>从底层编译的角度观察隐式类</h2><p>我们使用隐式类重新实现 <code>JDBC</code> 升级为 <code>MyBatis</code> 的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式类必须有且只有一个参数，该参数类型是要被拓展的类。</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Mybatis</span>(<span class="params">jDBC: <span class="type">JDBC</span></span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">val</span> url: <span class="type">String</span> = jDBC.url</span><br><span class="line">  <span class="keyword">val</span> maxConnection : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部可以定定义拓展的功能。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Pool</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">&quot;获取连接池&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>():<span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">&quot;删除数据&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------主函数的调用部分-----------------//</span></span><br><span class="line"><span class="keyword">val</span> jdbc = <span class="keyword">new</span> <span class="type">JDBC</span></span><br><span class="line">jdbc.<span class="type">Pool</span>()</span><br><span class="line">println(jdbc.maxConnection)</span><br></pre></td></tr></table></figure>

<p>刚才提到，我们无法在<code>.scala</code>文件中对隐式类做顶级声明（指将它当作是一个独立的类来声明）。因为在底层，隐式类总会被当作是一个内部类被编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scalaTest;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplicitTransform</span>$<span class="title">Mybatis</span>$2</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnection;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对val变量只编译 get 方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">url</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.url; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConnection</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.maxConnection; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Mybatis拓展的新方法  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pool</span><span class="params">()</span></span>&#123;<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;<span class="comment">//... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> ImplicitTransform$Mybatis$<span class="number">2</span>(JDBC jDBC)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = jDBC.url();</span><br><span class="line">    <span class="keyword">this</span>.maxConnection = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们无需纠结 <code>.class</code> 文件中大量的 <code>$</code> 符号，仅需知道编译器会在隐式类生效的作用域内声明一个 <code>JDBC -&gt; Mybatis</code> 的隐式转换函数。当 <code>JDBC</code> 对象调用了 <code>Mybatis</code> 的成员时，则自动使用该隐式转换函数，使用 <code>Mybatis</code> 实例替换掉 <code>JDBC</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scalaTest;</span><br><span class="line"><span class="comment">//忽略部分import</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplicitTransform</span>$</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//忽略MODULE$相关的代码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    JDBC jdbc = <span class="keyword">new</span> JDBC();</span><br><span class="line">    Mybatis$<span class="number">1</span>(jdbc).Pool();</span><br><span class="line">   	<span class="comment">//忽略其它代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在使用隐式类的地方又声明了一个隐式转换函数。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImplicitTransform.Mybatis$<span class="number">2</span> Mybatis$<span class="number">1</span>(JDBC jDBC)</span><br><span class="line">  &#123;<span class="keyword">return</span> <span class="keyword">new</span> ImplicitTransform.Mybatis$<span class="number">2</span>(jDBC);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="隐式转换函数和隐式类总结"><a href="#隐式转换函数和隐式类总结" class="headerlink" title="隐式转换函数和隐式类总结"></a>隐式转换函数和隐式类总结</h1><h2 id="隐式转换的时机"><a href="#隐式转换的时机" class="headerlink" title="隐式转换的时机"></a>隐式转换的时机</h2><ol>
<li>当引用类型和实际指向的对象不属于同一个类，也不能转换成上转型对象时。</li>
<li>一个类使用了自身不存在的属性或方法。</li>
<li>使用了视图界定或者是上下文界定（它和泛型有关系，泛型会在后续的blog中分析，因为它有一些概念要比 Java 更加复杂）。</li>
</ol>
<h2 id="隐式转换的运行机制"><a href="#隐式转换的运行机制" class="headerlink" title="隐式转换的运行机制"></a>隐式转换的运行机制</h2><p>如果形如 <code>S = T</code> 的赋值发生了隐式转换：</p>
<ol>
<li>编译器会在首先在上下文环境下查找可用的隐式类，隐式函数。</li>
<li>如果没有在上下文中找到，则会深入到 <code>T</code> 类型内部寻找可用的隐式转换规则 ，且情况更加复杂：<ul>
<li>如果类型 <code>T</code> 混入了特质，则在隐式解析 <code>T</code> 的过程中，编译器会将这些特质也全部搜索一遍。</li>
<li>如果 <code>T</code> 包含了类型参数，比如 <code>List[String]</code> ，则隐式转换时 <code>List</code> 和 <code>String</code> 都会被编译器搜索。</li>
<li>如果 <code>T</code> 是一个路径依赖类型 <code>instance.T</code> ，则编译器会搜索对象 <code>instance</code> 和内部类 <code>T</code> 。</li>
<li>如果 <code>T</code> 是一个使用类型投影的内部类 <code>Clazz#T</code>，则编译器会搜索 <code>Clazz</code> 类和内部类 <code>T</code>。</li>
</ul>
</li>
</ol>
<p>一般情况下，都应该尽可能让编译器通过第一种方式就可以找到合适的转换规则。否则，不仅会增大编译器的工作负担，也会让后续的代码维护者难以定位到隐式转换的具体声明位置。</p>
<h1 id="隐式值和隐式参数"><a href="#隐式值和隐式参数" class="headerlink" title="隐式值和隐式参数"></a>隐式值和隐式参数</h1><h2 id="定义隐式值"><a href="#定义隐式值" class="headerlink" title="定义隐式值"></a>定义隐式值</h2><p>隐式值用于自定义某个数据类型的默认赋值，并配合隐式参数来使用。定义隐式值需要在前面加上 <code>implicit</code> 关键字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绝大部分情况，隐式值都是不允许被篡改的，因此我们使用 val 而非 var。</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> defaultString: <span class="type">String</span> = <span class="string">&quot;null string.&quot;</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> defaultInt : <span class="type">Int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> defaultDouble : <span class="type">Double</span> = <span class="number">200.00</span>d</span><br></pre></td></tr></table></figure>

<p>现定义一个新的隐式函数，然后在参数列表中开头同样加上 <code>implicit</code> 关键字表示：这个参数列表里<strong>所有的参数全部为隐式参数</strong>，换句话说，<code>string</code> 和 <code>int</code> 全都是隐式参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usingImplicitValue</span></span>(<span class="keyword">implicit</span> string: <span class="type">String</span>,int: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐式参数意味着当调用该函数且没有显式地传入形参时，其值由上下文环境中定义的隐式值来提供。隐式变量同样可以声明默认参数值，类似这种写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usingImplicitValue</span></span>(<span class="keyword">implicit</span> string: <span class="type">String</span> = <span class="string">&quot;null String&quot;</span> ,int: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当编译器没有在上下文找到可用的隐式转换时，就会使用默认参数值。</p>
<h2 id="区别不同的概念"><a href="#区别不同的概念" class="headerlink" title="区别不同的概念"></a>区别不同的概念</h2><p>不要和将隐式值和类声明内部的默认值相混淆。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clazz</span></span>&#123;</span><br><span class="line">  <span class="comment">// _ 占位符表示赋默认值。</span></span><br><span class="line">  <span class="keyword">val</span> value : <span class="type">Int</span> = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认值和隐式值的用途并不一样：</p>
<ol>
<li>默认值在初始化值时使用，它的值都是由 Scala 给定的：如 <code>Int</code> 的默认值固定为 <code>0</code> ，引用类型的默认值默认为 <code>null</code> 。</li>
<li>隐式值用于<strong>程序开发者在某个上下文中规定某种数据类型的默认值</strong>，换句话说，开发者可以通过隐式值规定 <code>Int</code> 的默认值为 <code>-1</code> ，而非 <code>0</code> 。</li>
</ol>
<p>同样的，隐式值和默认参数值也不同。比如说下面的 <code>int</code> 仅具备默认参数值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此为默认参数值。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span></span>(int : <span class="type">Int</span> = <span class="number">100</span>): <span class="type">Int</span> =&#123;int * <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>它和隐式值的区别是：</p>
<ol>
<li>默认参数值仅在调用此函数，且没有为指定参数显式赋值时才生效。</li>
<li>隐式值可用在作用域内任何一个声明了隐式参数且类型匹配的函数入参中。</li>
</ol>
<h2 id="使用隐式值和隐式参数细节"><a href="#使用隐式值和隐式参数细节" class="headerlink" title="使用隐式值和隐式参数细节"></a>使用隐式值和隐式参数细节</h2><p>隐式值和隐式参数的使用细节比较繁琐：</p>
<p>和隐式转换函数类似，<strong>同一个域及其子域</strong>内只允许存在一种数据类型的隐式值。当程序编译时报出 <code>ambigouous implicit values</code> 错误时，说明同一个数据类型的隐式值存在多个。<strong>因此当在小作用域内声明隐式值时，也要注意向上的大作用域内是否已经存在同类型的隐式值</strong>。</p>
<p>包含隐式参数的形参列表，在调用函数时可以省略不写，表示其隐式参数全部使用上下文提供的隐式值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果所有参数均使用隐式参数自动赋值，则不带括号。</span></span><br><span class="line">usingImplicitValue</span><br></pre></td></tr></table></figure>

<p>但是如果想要让隐式参数的值由<strong>默认参数值</strong>来提供，则需要带上空括号 <code>()</code> ，前提是隐式参数具备默认参数值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------修改函数----------------//</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usingImplicitValue</span></span>(<span class="keyword">implicit</span> string: <span class="type">String</span> = <span class="string">&quot;default value&quot;</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(string)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------主函数----------------//</span></span><br><span class="line"><span class="comment">//这种写法表示参数列表内全部都采用隐式值，无论默认参数值是否存在。</span></span><br><span class="line">usingImplicitValue</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种写法会调用行内的默认参数值。</span></span><br><span class="line">usingImplicitValue()</span><br></pre></td></tr></table></figure>

<p>另极力建议，若参数列表<strong>仅部分参数有默认值</strong>，则赋值的时候应通过 <code>name = value</code> 的写法明确表明将哪个值 <code>value</code> 赋值给哪个变量 <code>name</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usingImplicitValue</span></span>(explicitInt : <span class="type">Int</span> = <span class="number">100</span>, explicitDouble : <span class="type">Double</span>)( <span class="keyword">implicit</span> double : <span class="type">Double</span>,  int: <span class="type">Int</span> =<span class="number">12</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(double)</span><br><span class="line">      println(int)</span><br><span class="line">      println(explicitInt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 name = value 的格式指明赋值的参数和值。</span></span><br><span class="line">usingImplicitValue(explicitDouble = <span class="number">23</span>)(double = <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>如上述代码块所示，如果一个函数既存在普通参数，又存在隐式参数，则应该用分开的参数列表来表示，并且<strong>隐式参数的参数列表总是在最后一个位置</strong>。同一个参数列表里不能同时存在隐式参数和非隐式参数。如果某个参数列表的开头出现了 <code>implicit</code> 关键字，则说明该列表内的所有参数都是隐式参数。</p>
<p>这样的函数在调用时需要使用多个小括号 <code>()</code> 表示的参数列表分别进行赋值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usingImplicitValue</span></span>(explicitInt : <span class="type">Int</span> = <span class="number">100</span>)( <span class="keyword">implicit</span> double : <span class="type">Double</span> =<span class="number">10.00</span>,  int: <span class="type">Int</span>=<span class="number">100</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//第一个参数列表的所有参数都是非隐式参数。</span></span><br><span class="line">	println(explicitInt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二个参数列表的所有参数都是隐式参数。</span></span><br><span class="line">	println(double)</span><br><span class="line">	println(int)    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------表示全部采用显式赋值-------------------------//</span></span><br><span class="line">usingImplicitValue(<span class="number">101</span>)(<span class="number">21</span>,<span class="number">23</span>)</span><br><span class="line"><span class="comment">//-------------表示全部采用默认参数值-----------------------//</span></span><br><span class="line">usingImplicitValue()()</span><br><span class="line"><span class="comment">//---表示前一个参数列表使用默认参数值，而隐式参数全采用隐式值---//</span></span><br><span class="line">usingImplicitValue()</span><br><span class="line"><span class="comment">//-------------对部分参数进行指定赋值-----------------------//</span></span><br><span class="line">usingImplicitValue(explicitInt = <span class="number">101</span>)(int =<span class="number">201</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结三条"><a href="#总结三条" class="headerlink" title="总结三条"></a>总结三条</h2><ol>
<li>当某个参数列表内部以 <code>implicit</code> 关键字开头时，表示该列表内部都是隐式参数。在调用函数时不需要使用 <code>()</code>  为包含隐式参数的参数列表再单独赋值，除非你要显式地覆盖掉它们。上下文必须要声明对应每一个隐式参数的隐式值，或者隐式参数具有参数默认值。否则会提示错误： <code>could not find implicit value for parameter</code> 。</li>
<li>编译器优先在上下文环境中寻找匹配的隐式值，然后才会尝试寻找默认参数值。如果隐式参数既没有对应的隐式值，也没有行内的默认值，调用函数也没有 <code>()</code> 主动传参时，则编译器会报错。然而，<strong>不建议隐式参数和默认参数值混用，因为这样的代码会非常的混乱</strong>。</li>
<li>其它没有使用 <code>implicit</code> 关键字开头的参数列表（即通常意义上的参数列表），则在调用时要么主动为参数赋值，要么参数具有行内的默认参数值。若两者都不存在，则报错：<code>not enough arguments for method xxx</code> 。</li>
</ol>
<h1 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h1><p>Scala 的特点是允许使用字母外的符号作为函数标识符。我们可以选择对 <code>+</code>,<code>-</code>,<code>*</code>,<code>\</code> 进行操作符重载，或者是重现 <code>++</code>，<code>--</code> 等其它语言中常使用的 “自增”，”自减” 功能，或者是实现简单的内部 DSL 特性。在后续的 blog 中会通过解析器组合子进一步阐述 DSL 的基本实现，它将是隐式转换和函数式编程的综合应用。</p>
<h2 id="自定义中置运算符"><a href="#自定义中置运算符" class="headerlink" title="自定义中置运算符"></a>自定义中置运算符</h2><p>对于参数列表仅有一个参数的函数，可以将该函数的标识符理解成一个双目运算符 (或称中置运算符) ：第一个参数是调用此函数的对象本身 ( <code>this</code> ) ，第二个参数是参数列表中的那个唯一参数。</p>
<p>举个例子，下面有一个 <code>Wallet</code> 类，它重载了 <code>+</code> 符号，该函数接收另一个 <code>Wallet</code> 实例作为参数。现在 <code>+</code> 的语义是：将当前的 <code>Wallet</code> 钱包对象和另一个 <code>Wallet</code> 钱包对象的余额相加，并返回一个新的 <code>Wallet</code> 对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OperatorOverride</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wallet1 = <span class="type">Wallet</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> wallet2 = <span class="type">Wallet</span>(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用自定义的 + 法</span></span><br><span class="line">    println((wallet1 + wallet2).balance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个样例类，它默认提供apply方法。</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span>(<span class="params">var balance:<span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//定义一个钱包类的加法：返回一个新钱包，余额是两个钱包余额之和。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(wallet: <span class="type">Wallet</span>): <span class="type">Wallet</span> =&#123;</span><br><span class="line">    <span class="type">Wallet</span>(<span class="keyword">this</span>.balance + wallet.balance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前，我们通常需要使用这种方式实现调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> wallet3 : <span class="type">Wallet</span> = wallet1.+(wallet2)</span><br></pre></td></tr></table></figure>

<p>不过，Scala 还留下了一个有趣的语法糖。我们可以用中缀表达式写法来替换掉  <code>.</code>  访问符的方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上是相当于 wallet1.+(wallet2)</span></span><br><span class="line"><span class="keyword">val</span> wallet3 : <span class="type">Wallet</span> = wallet1 + wallet2</span><br></pre></td></tr></table></figure>

<p>这对于下文的后置运算符，前置运算符也同理。</p>
<h2 id="自定义后置运算符"><a href="#自定义后置运算符" class="headerlink" title="自定义后置运算符"></a>自定义后置运算符</h2><p>如果我们定义的函数没有参数，则可以将该函数的标识符理解成不需要另一个操作数的后置运算符（单目运算符），典型的是我们在其它语言中常用的 <code>++</code> ，或者是 <code>--</code> 等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wallet内新增方法：</span></span><br><span class="line">  <span class="comment">//定义钱包的自增加法：钱包的余额+1,并返回余额。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>() : <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="comment">//不能在函数体内嵌套调用++运算符。</span></span><br><span class="line">    <span class="keyword">this</span>.balance +=<span class="number">1</span></span><br><span class="line">    balance</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//-----------主函数调用------------//</span></span><br><span class="line">	print(wallet1 ++)</span><br><span class="line">	<span class="comment">//单独使用时，加上;表示这个语句结尾了。</span></span><br><span class="line">	wallet ++;</span><br></pre></td></tr></table></figure>

<p>不过，编译器可能会将 <code>wallet ++</code> 理解成是一个没有写完的中缀表达式，并将下一行语句当作是入参而引发错误（因为 <code>++</code> 方法不需要其它参数）。为了避免这种误解，使用后置运算符之后在行末尾最好加上 <code>;</code> 收尾。</p>
<h2 id="自定义前置运算符"><a href="#自定义前置运算符" class="headerlink" title="自定义前置运算符"></a>自定义前置运算符</h2><p>同理，我们也可以重写一些典型的前置运算符，比如取反操作符号 <code>!</code>。我们可以在某个类中重新定义前置运算符  <code>!</code> 表示的实际含义：比如声明<code>!wallet</code>代表将这个钱包的余额清空。注意声明前置运算符时，函数标识符前面还需要额外加一个前缀 <code>unary_</code>。</p>
<p>其它可以用于充当前置运算符的还有：<code>+</code>, <code>-</code>, <code>~</code>。<strong>和中置运算符，后置运算符不同的是，除了此四个符号以外的其它符号/英文标识符不可以用于前置运算符</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wallet内新增方法：</span></span><br><span class="line">   <span class="comment">//定义一个前置运算符!，前面还需要加上一个unary_进行标注。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unary_!</span></span>() : <span class="type">Int</span> =&#123;</span><br><span class="line">    <span class="keyword">this</span>.balance = <span class="number">0</span></span><br><span class="line">    balance</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//---------主函数调用-----------//</span></span><br><span class="line"> <span class="comment">//调用自定义的!方法。</span></span><br><span class="line">    print(!wallet1)</span><br></pre></td></tr></table></figure>

<h2 id="案例：实现隐式地单位转换"><a href="#案例：实现隐式地单位转换" class="headerlink" title="案例：实现隐式地单位转换"></a>案例：实现隐式地单位转换</h2><p>对于大部分工具而言，它们设定的时间参数都是以 “毫秒” 为单位的。比如让当前线程睡眠 3 秒钟 ，需要换算成以毫秒为单位的 <code>3000</code> 作为参数传递进去：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span>.sleep(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>现在尝试实现这样的语法糖：用 <code>3 second</code> 这种 “数值 + 单位” 的写法来替换掉  <code>3000</code>，让程序变得更具有可读性。</p>
<p>时间的数值部分使用 <code>Int</code> 类型来表示，因此我们可以创建一个隐式类（或者隐式函数），它能够接收表示时间值的 <code>Int</code> 数据，当调用其 <code>second</code> , <code>minute</code> 等后置运算符（ 我们从习惯上称它们是 “单位” ），让程序自动根据单位将其转化为对应的毫秒数值。下面给出代码的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDuration</span>(<span class="params">millis_ : <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">millis</span> </span>: <span class="type">Int</span> = millis_</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span> </span>: <span class="type">Int</span> = millis_ * <span class="number">1000</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minute</span> </span>: <span class="type">Int</span> = millis_ * <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>现在我们想要表达 3 秒钟 ，仅需要用这样的替代表示：<code>3 second</code> 。而想要表达 1 分钟，仅需要用 <code>1 minute</code> 来表述，而不是 <code>60 * 1000</code> 。我们只需要对 <code>millis_</code> 本身进行进制转换，而不依赖外部的任何其它变量，因此定义的 <code>millis</code> , <code>seconds</code> 等函数都是不需要括号的<strong>无参数函数</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值 + 单位 的表示法更符合人们理解的逻辑。</span></span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">3</span> second)</span><br></pre></td></tr></table></figure>

<p>至于为什么有选择无参数函数，有时却又选择空括号函数，这其实取决于该函数本身会不会产生副作用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6875504470239739917" >Scala之：隐式转换与自定义操作符<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/04/07/Scala%E4%B8%AD%E7%9A%84_/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Scala中的_</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            


        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">echohlne</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">隐式转换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">隐式转换函数实现转换数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AE%9E%E7%8E%B0Map%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.</span> <span class="nav-text">利用隐式转换实现Map映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E7%9A%84-OCP-%E5%93%B2%E5%AD%A6"><span class="nav-number">1.3.</span> <span class="nav-text">隐式转换函数的 OCP 哲学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%E8%A6%81%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">隐式转换函数总结要点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">隐式类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%BA%95%E5%B1%82%E7%BC%96%E8%AF%91%E7%9A%84%E8%A7%92%E5%BA%A6%E8%A7%82%E5%AF%9F%E9%9A%90%E5%BC%8F%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">从底层编译的角度观察隐式类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">隐式转换函数和隐式类总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">隐式转换的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">隐式转换的运行机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%80%BC%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">隐式值和隐式参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E5%80%BC"><span class="nav-number">4.1.</span> <span class="nav-text">定义隐式值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.2.</span> <span class="nav-text">区别不同的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E5%80%BC%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E7%BB%86%E8%8A%82"><span class="nav-number">4.3.</span> <span class="nav-text">使用隐式值和隐式参数细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%89%E6%9D%A1"><span class="nav-number">4.4.</span> <span class="nav-text">总结三条</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">自定义操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.1.</span> <span class="nav-text">自定义中置运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">自定义后置运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%89%8D%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">自定义前置运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%9A%90%E5%BC%8F%E5%9C%B0%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.</span> <span class="nav-text">案例：实现隐式地单位转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
